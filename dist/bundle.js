/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./myReact/js/myHook/GlobalFiber.js":
/*!******************************************!*\
  !*** ./myReact/js/myHook/GlobalFiber.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.updateWorkInProgressHook = exports.global = exports.fiber = void 0;\r\n//todo ------------------全局使用的结构和变量 方法-----------------------------\r\n//! --------组件对应的fiber---------------------\r\nlet fiber = {\r\n    memorizedState: null,\r\n    stateNode: () => { },\r\n    updateQueue: null,\r\n    fiberFlags: 'mount',\r\n    hasRef: false,\r\n    ref: null,\r\n    children: null,\r\n    props: null,\r\n    tag: null,\r\n    text: null,\r\n};\r\nexports.fiber = fiber;\r\n//! -----需要使用的全局变量---------------\r\nconst global = {\r\n    workInProgressHook: { currentHook: null },\r\n    hookIndex: 0 //用于更新hook时找到对应的hook\r\n};\r\nexports.global = global;\r\n//! ----------拿取需要本次update需要更新的hook----------------------\r\nfunction updateWorkInProgressHook(index) {\r\n    let currentHook = fiber.memorizedState;\r\n    while (currentHook && currentHook.index != index) {\r\n        currentHook = currentHook.next;\r\n    }\r\n    // 因为链表是按顺序的 所以这个函数每执行一次就新增一个\r\n    global.hookIndex += 1;\r\n    return currentHook;\r\n}\r\nexports.updateWorkInProgressHook = updateWorkInProgressHook;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/GlobalFiber.js?");

/***/ }),

/***/ "./myReact/js/myHook/render.js":
/*!*************************************!*\
  !*** ./myReact/js/myHook/render.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.render = void 0;\r\nconst GlobalFiber_1 = __webpack_require__(/*! ./GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\nconst createFiberTree_1 = __webpack_require__(/*! ../myJsx/createFiberTree */ \"./myReact/js/myJsx/createFiberTree.js\");\r\n//! render分为2部分  render阶段 - commit阶段  最后unmount\r\n//! ----------------模拟render部分------------------------\r\n//! 更改并生成fiber树  (结束后fiber由mount变为update)\r\nfunction renderPart(functionComponent) {\r\n    GlobalFiber_1.fiber.stateNode = functionComponent; // 挂载组件到fiber上\r\n    const app = functionComponent(); // 执行App 获取html模板\r\n    const fiberTree = (0, createFiberTree_1.createFiberTree)(app); //根据模板渲染fiberTree\r\n    resetFiber(fiberTree); //! 挂载更新好的fiberTree到全局\r\n    GlobalFiber_1.fiber.fiberFlags = 'update'; //render阶段结束fiber的状态由mount为update\r\n    return app;\r\n}\r\n//! 赋值虚拟节点的属性给fiberNode\r\nfunction resetFiber(newFiber) {\r\n    const { children, props, tag, text } = newFiber;\r\n    GlobalFiber_1.fiber.children = children;\r\n    GlobalFiber_1.fiber.props = props;\r\n    GlobalFiber_1.fiber.tag = tag;\r\n    GlobalFiber_1.fiber.text = text;\r\n}\r\n//! -----------------模拟Commit阶段-----------------------------\r\n//! 分为三部分  beforeMutation  mutation  layout阶段\r\n//! before 前置处理  mutation 渲染dom节点   layout  处理useEffect useLayoutEffect\r\nfunction commitPart(rootDom) {\r\n    console.log('本次commit的fiber', GlobalFiber_1.fiber);\r\n    //todo  mutation阶段\r\n    const html = createHtml(GlobalFiber_1.fiber); //根据fiberTree创建html\r\n    const childDom = rootDom.children[0];\r\n    if (childDom) {\r\n        rootDom.removeChild(childDom);\r\n    } //删除之前的dom\r\n    rootDom.appendChild(html); //添加渲染好的dom\r\n    //todo  layout阶段  调用Effects链表 执行create函数()\r\n    let destoryEffectsArr = [];\r\n    if (GlobalFiber_1.fiber.updateQueue !== null) {\r\n        const createEffectsArr = createCallbackQueue();\r\n        destoryEffectsArr = doCreateQueue(createEffectsArr);\r\n    }\r\n    //todo 处理ref\r\n    GlobalFiber_1.fiber.ref = rootDom; //挂载ref\r\n    if (GlobalFiber_1.fiber.hasRef) {\r\n        // commitAttachRef()//绑定ref\r\n    }\r\n    return destoryEffectsArr;\r\n}\r\n//todo 遍历Effect链表 将需要执行的Effect推入数组--------------\r\nfunction createCallbackQueue() {\r\n    const createEffectsArr = [];\r\n    const lastEffect = GlobalFiber_1.fiber.updateQueue.lastEffect;\r\n    const firstEffect = lastEffect.next;\r\n    let currentEffect = firstEffect;\r\n    do {\r\n        // Fiber=mount 时 depNochange执行depChange执行\r\n        // Fiber=update时 depChange执行 \r\n        //判断effectTag决定是否执行Effect(mount和dep变更时执行)\r\n        const isFiberMount = Boolean(GlobalFiber_1.fiber.fiberFlags === 'mount');\r\n        const isDepChange = Boolean(currentEffect.tag === 'depChanged');\r\n        //将create函数推入数组  \r\n        if (isFiberMount || isDepChange) {\r\n            createEffectsArr.push(currentEffect);\r\n        }\r\n        currentEffect = currentEffect.next;\r\n    } while (currentEffect !== firstEffect);\r\n    return createEffectsArr;\r\n}\r\n//todo 遍历执行需要执行的Effect---生成destory---------\r\nfunction doCreateQueue(createEffectsArr) {\r\n    const destoryEffectsArr = [];\r\n    //todo 遍历Effects数组 执行create  \r\n    //todo 生成destoryEffect数组 将destory存放到对应的Effect上\r\n    for (let i = 0; i < createEffectsArr.length; i++) {\r\n        const destory = createEffectsArr[i].create(); // 执行create\r\n        if (destory) {\r\n            createEffectsArr[i].destory = destory; // 赋值destory\r\n            destoryEffectsArr.push(createEffectsArr[i]); //推入destory数组\r\n        }\r\n    }\r\n    return destoryEffectsArr;\r\n}\r\n//!  -------------根据fiberTree创建html------------------\r\n//todo 根据tag创建节点  填充text  递归appendChild\r\nfunction appendDom(fiber, container) {\r\n    //todo 如果是小写 判断为html标签  填充文本 处理属性\r\n    const dom = document.createElement(fiber.tag);\r\n    handleProps(fiber, dom);\r\n    if (fiber.text) {\r\n        dom.innerHTML = fiber.text;\r\n    }\r\n    //todo 如果有children深度优先递归渲染dom节点 \r\n    if (fiber.children) {\r\n        fiber.children.forEach((fiber) => {\r\n            appendDom(fiber, dom);\r\n        });\r\n    }\r\n    container.appendChild(dom);\r\n}\r\n//! 对标签中的属性进行处理 给dom节点添加标签 (未完成)\r\nfunction handleProps(curFiber, dom) {\r\n    const props = curFiber.props;\r\n    for (let key in props) {\r\n        const value = props[key];\r\n        //todo  处理className\r\n        switch (key) {\r\n            case 'className':\r\n                dom.setAttribute(\"class\", value);\r\n                break;\r\n            case 'onClick':\r\n                //! 使用{addNun} 挂载到全局方法\r\n                const newValue = value.slice(1, value.length - 1);\r\n                const fn = window['$$' + newValue];\r\n                dom.addEventListener(\"click\", fn);\r\n                break;\r\n            default:\r\n                dom.setAttribute(key, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n//!根据fiberTree创建html\r\n//此方法可以随时停止  传入需要改变的fiberNode实现最小量更新\r\nconst createHtml = (fiberTree) => {\r\n    const container = document.createDocumentFragment();\r\n    appendDom(fiberTree, container);\r\n    return container;\r\n};\r\n//! ---------- unmount阶段 -------------------------\r\n//todo  清空上一次执行完的updateQueue 重置HookIndex 执行distory函数数组\r\nfunction unmountPart(destoryEffectsArr) {\r\n    doDestoryQueue(destoryEffectsArr);\r\n    GlobalFiber_1.fiber.updateQueue = null;\r\n    GlobalFiber_1.global.hookIndex = 0;\r\n}\r\n//todo -----在unmounted时执行destorys数组\r\nfunction doDestoryQueue(destoryEffectsArr) {\r\n    for (let i = 0; i < destoryEffectsArr.length; i++) {\r\n        const destory = destoryEffectsArr[i].destory;\r\n        if (destory) {\r\n            destory();\r\n        }\r\n    }\r\n}\r\n//!--------------Render方法-------------------\r\nfunction render(functionComponent, rootDom) {\r\n    console.log('------------render-------------');\r\n    const app = renderPart(functionComponent); //todo render阶段\r\n    const destoryEffectsArr = commitPart(rootDom); //todo commit阶段\r\n    unmountPart(destoryEffectsArr); //todo unmount阶段\r\n    return app;\r\n}\r\nexports.render = render;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/render.js?");

/***/ }),

/***/ "./myReact/js/myHook/useEffect.js":
/*!****************************************!*\
  !*** ./myReact/js/myHook/useEffect.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.myUseEffect = void 0;\r\n//修改全局变量的方法\r\nconst GlobalFiber_1 = __webpack_require__(/*! ./GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\n//! -------mountEffect(useEffect第一次执行)-------------\r\nfunction mountEffect(fiberFlags, hookFlags, create, deps) {\r\n    //todo 创建Hook 成为fiber.memorizedState上的一项Hook (单向链表)\r\n    const hook = mountWorkInProgressHook();\r\n    //判断是否传入deps 不同时机执行useEffect\r\n    const nextDeps = deps === undefined ? null : deps;\r\n    //执行mountEffect 改变fiberFlages\r\n    //! fiber.fiberFlags = fiberFlags\r\n    //此时memorizedState保存的就是最后更新的Effect数据(第一次destory为undefined)\r\n    hook.memorizedState = pushEffect('depNoChange', create, undefined, nextDeps);\r\n    //todo mount后 hookFlag变为update\r\n    hook.hookFlags = 'update';\r\n}\r\n//! --------创建一个Hook 形成环链表 添加到hook队列--------------\r\nfunction mountWorkInProgressHook() {\r\n    //todo 新建一个hook\r\n    const newHook = {\r\n        index: 0,\r\n        memorizedState: null,\r\n        hookFlags: 'mount',\r\n        next: null\r\n    };\r\n    // 添加Hook进单向链表\r\n    if (GlobalFiber_1.fiber.memorizedState !== null) {\r\n        const lastHook = GlobalFiber_1.fiber.memorizedState;\r\n        newHook.index = lastHook.index + 1;\r\n        newHook.next = lastHook;\r\n        GlobalFiber_1.fiber.memorizedState = newHook;\r\n    }\r\n    //接入hook到fiber上\r\n    GlobalFiber_1.fiber.memorizedState = newHook;\r\n    //接入hook到workProgress\r\n    GlobalFiber_1.global.workInProgressHook.currentHook = newHook;\r\n    return newHook;\r\n}\r\n//! -------updateEffect(useEffect后续更新)-------------\r\nfunction updateEffect(fiberFlags, hookFlags, create, deps) {\r\n    const currentHook = (0, GlobalFiber_1.updateWorkInProgressHook)(GlobalFiber_1.global.hookIndex);\r\n    //判断是否传入deps 不同时机执行useEffect\r\n    const nextDeps = deps === undefined ? null : deps;\r\n    //!执行updateEffect 改变fiberFlages\r\n    //! fiber.fiberFlags = fiberFlags\r\n    //todo  如果有currentHook 获得上一次执行create返回的的销毁函数\r\n    if (currentHook !== null) {\r\n        const prevEffect = currentHook.memorizedState; //最后一次Effect\r\n        //todo update时从上一次的Effect中取出销毁函数(在commit阶段执行create函数并赋值了destory)\r\n        const destory = prevEffect.destory;\r\n        //todo 浅比较上次和本次的deps是否相等(遍历每一项deps进行比较) \r\n        //todo 依赖项改变和不改变  传入不同的tag  用于减少更新\r\n        if (nextDeps !== null) {\r\n            const prveDeps = prevEffect.deps;\r\n            if (shallowCompareDeps(nextDeps, prveDeps)) {\r\n                pushEffect('depNoChange', create, destory, nextDeps);\r\n                return;\r\n            }\r\n            //todo 如果deps发生改变  传入的tag为'depChanged' commit时这个Effects才会被执行\r\n            //todo  (执行的最后一个effect要被赋值给memorizedState)\r\n            else {\r\n                currentHook.memorizedState = pushEffect('depChanged', create, destory, nextDeps);\r\n            }\r\n        }\r\n    }\r\n}\r\n//! ------浅比较前后deps是否发生变化-------------------\r\nfunction shallowCompareDeps(nextDeps, prveDeps) {\r\n    //todo console.log('前后dep对比', prveDeps, nextDeps);\r\n    // 选取最大的lenght\r\n    const length = nextDeps.length > prveDeps.length ? nextDeps.length : prveDeps.length;\r\n    let res = true;\r\n    for (let i = 0; i < length; i++) {\r\n        if (nextDeps[i] !== prveDeps[i])\r\n            return res = false;\r\n    }\r\n    return res;\r\n}\r\n//! --------pushEffect创建/增加Effects更新链表---------------\r\nfunction pushEffect(tag, create, destory, deps) {\r\n    // 创建Effect \r\n    const effect = {\r\n        tag,\r\n        create,\r\n        destory,\r\n        deps,\r\n        next: null\r\n    };\r\n    //todo 如果Hook上没有更新链表  创建更新链表  如果有则插入一个effect到更新环链表尾部\r\n    const updateQueue = { lastEffect: null };\r\n    if (GlobalFiber_1.fiber.updateQueue === null) {\r\n        updateQueue.lastEffect = effect.next = effect; // 自身形成环状链表\r\n        //更新fiber上的updateQueue环链表\r\n        GlobalFiber_1.fiber.updateQueue = updateQueue;\r\n    }\r\n    else {\r\n        const lastEffect = GlobalFiber_1.fiber.updateQueue.lastEffect;\r\n        if (lastEffect === null) { //todo 有链表结构但是链表为空\r\n            updateQueue.lastEffect = effect.next = effect; // 自身形成环状链表\r\n        }\r\n        else { // todo 插入effect到环链表尾端\r\n            const firstEffect = lastEffect.next;\r\n            lastEffect.next = effect;\r\n            effect.next = firstEffect;\r\n            updateQueue.lastEffect = effect; //此时环链表上的最后一项就是effect\r\n            //更新fiber上的updateQueue环链表\r\n            GlobalFiber_1.fiber.updateQueue = updateQueue;\r\n        }\r\n    }\r\n    //todo 返回这个Effect 会被赋值给hook.memorizedState(最后一次更新的状态)\r\n    return effect;\r\n}\r\n//!------------useEffect主体--------------\r\nfunction myUseEffect(create, deps) {\r\n    const nextDeps = deps === undefined ? null : deps;\r\n    // 第一次useEffect执行mountEffect\r\n    if (GlobalFiber_1.fiber.fiberFlags === 'mount') {\r\n        const hookFlags = 'mount';\r\n        mountEffect('mount', hookFlags, create, nextDeps);\r\n        // 后续useEffect执行updateEffect\r\n    }\r\n    else if (GlobalFiber_1.fiber.fiberFlags === 'update') {\r\n        const hookFlags = 'update';\r\n        updateEffect('update', hookFlags, create, nextDeps);\r\n    }\r\n}\r\nexports.myUseEffect = myUseEffect;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/useEffect.js?");

/***/ }),

/***/ "./myReact/js/myHook/useState.js":
/*!***************************************!*\
  !*** ./myReact/js/myHook/useState.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.myUseState = void 0;\r\nconst render_1 = __webpack_require__(/*! ./render */ \"./myReact/js/myHook/render.js\");\r\n// 全局变量和当前 Fiber\r\nconst GlobalFiber_1 = __webpack_require__(/*! ./GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\n//! ---------------useState返回的updater方法(updateState方法)-------------------\r\nfunction dispatchAction(queue, newVal, action) {\r\n    //创建updater环链表\r\n    const updater = {\r\n        action: newVal || action,\r\n        next: null\r\n    };\r\n    //pending上没有updater 自己形成环状链表  ; 有updater链表  插入一个updater\r\n    if (queue.pending === null) {\r\n        updater.next = updater;\r\n    }\r\n    else {\r\n        updater.next = queue.pending.next;\r\n        queue.pending.next = updater;\r\n    }\r\n    // 让此updater成为lastUpdater\r\n    queue.pending = updater;\r\n    //! 重新render组件  这里需要调用unmount生命周期钩子\r\n    //! 源码中使用切换fiber树的方式执行重新渲染 不需要执行生命周期(处理fiber树时变相执行了unmount阶段)\r\n    GlobalFiber_1.fiber.updateQueue = null;\r\n    GlobalFiber_1.global.hookIndex = 0;\r\n    //todo 多个setState会触发多个render  实际上会将多个setState合并执行\r\n    (0, render_1.render)(GlobalFiber_1.fiber.stateNode, GlobalFiber_1.fiber.ref);\r\n}\r\n//! 创建一个useStateHook并添加到链表中------------------------\r\nfunction createHook(initialState) {\r\n    // 创建useState类型的hook\r\n    const hook = {\r\n        hookFlags: 'mount',\r\n        index: GlobalFiber_1.fiber.memorizedState ? GlobalFiber_1.fiber.memorizedState.index + 1 : 0,\r\n        memorizedState: initialState,\r\n        updateStateQueue: { pending: null },\r\n        next: null\r\n    };\r\n    // 将hook添加到fiber上,且将hook链接到全局hooks链表上  成为last项\r\n    if (!GlobalFiber_1.fiber.memorizedState) {\r\n        GlobalFiber_1.global.workInProgressHook.currentHook = hook;\r\n    }\r\n    else {\r\n        const lastEffect = GlobalFiber_1.fiber.memorizedState;\r\n        hook.next = lastEffect;\r\n    }\r\n    GlobalFiber_1.global.workInProgressHook.currentHook = hook;\r\n    GlobalFiber_1.fiber.memorizedState = hook;\r\n    return hook;\r\n}\r\n//! 更新该Hook的memorizedState-----------------------------\r\nfunction updateUseStateHook(hook) {\r\n    // 取出更新链表上的最后一个state\r\n    let baseState = hook.memorizedState;\r\n    //pending保存了链表最后一项   next就指向第一个update\r\n    if (hook.updateStateQueue.pending) {\r\n        let firstUpdate = hook.updateStateQueue.pending.next;\r\n        // queue链表 执行update(执行update上的action(update传入的参数 num=>num+1))  \r\n        do {\r\n            const action = firstUpdate.action;\r\n            //todo 更新baseState 分为传入函数和传入newValue两种情况\r\n            baseState = typeof action === 'function'\r\n                ? action(baseState)\r\n                : action;\r\n            firstUpdate = firstUpdate.next; // 链表后移\r\n            // 终止遍历链表\r\n        } while (firstUpdate !== hook.updateStateQueue.pending.next);\r\n        // 清空state更新链表\r\n        hook.updateStateQueue.pending = null;\r\n    }\r\n    // 遍历结束 将更新后的baseState存放到hook.memorizedState上\r\n    hook.memorizedState = baseState;\r\n    return baseState;\r\n}\r\n//! ----------执行useState会执行state的计算过程----------------\r\nfunction myUseState(initialState) {\r\n    //取出当前hook 如果是mount阶段就创建一个hook(初始值为initState)\r\n    let hook;\r\n    if (GlobalFiber_1.fiber.fiberFlags === 'mount') {\r\n        hook = createHook(initialState); //创建hook 添加到hook链表\r\n    }\r\n    else {\r\n        // 更新情况 找到对应的hook\r\n        hook = (0, GlobalFiber_1.updateWorkInProgressHook)(GlobalFiber_1.global.hookIndex);\r\n    }\r\n    //todo 更新hook上保存的state\r\n    const baseState = updateUseStateHook(hook);\r\n    //todo 执行完useState 钩子状态变为update\r\n    hook.hookFlags = 'update';\r\n    //todo 返回最新的状态 和updateAction\r\n    return [baseState, dispatchAction.bind(null, hook.updateStateQueue)];\r\n}\r\nexports.myUseState = myUseState;\r\n//useState执行逻辑\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/useState.js?");

/***/ }),

/***/ "./myReact/js/myJsx/createFiberTree.js":
/*!*********************************************!*\
  !*** ./myReact/js/myJsx/createFiberTree.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.createFiberTree = void 0;\r\nconst tplToVnode_1 = __webpack_require__(/*! ./tplToVnode */ \"./myReact/js/myJsx/tplToVnode.js\");\r\n//! 创建fiberNode树(Vnode树)\r\n//! 深度优先遍历vnode树  包装成fiberNode\r\nfunction creatFiberNode(vnode) {\r\n    //todo 从vnode中解构出需要的值\r\n    let { children = [], props, tag, text } = vnode;\r\n    const fiberNode = {\r\n        memorizedState: null,\r\n        stateNode: () => { },\r\n        updateQueue: null,\r\n        fiberFlags: 'mount',\r\n        hasRef: false,\r\n        ref: null,\r\n        children,\r\n        props,\r\n        tag,\r\n        text,\r\n    };\r\n    //TODO -----------如果tag大写 解析为组件(此时无children) ----------------\r\n    //todo 生成子vnodeTree挂载到cihldren上\r\n    if (tag[tag.length - 1] == '/') {\r\n        tag = tag.slice(0, tag.length - 1);\r\n        fiberNode.tag = tag;\r\n    }\r\n    if (tag[0] == tag[0].toUpperCase()) {\r\n        fiberNode.stateNode = window['$$' + tag];\r\n        const html = fiberNode.stateNode();\r\n        const childVnode = (0, tplToVnode_1.tplToVDOM)(html);\r\n        children.unshift(childVnode);\r\n    }\r\n    //todo 如果有children 深度优先遍历  包装成fiberNode\r\n    if (children) {\r\n        for (let i = 0; i < children.length; i++) {\r\n            const vnode = children[i];\r\n            fiberNode.children[i] = creatFiberNode(vnode);\r\n        }\r\n    }\r\n    return fiberNode;\r\n}\r\nfunction createFiberTree(htmlTplStr) {\r\n    const vnode = (0, tplToVnode_1.tplToVDOM)(htmlTplStr);\r\n    const fiberTree = creatFiberNode(vnode);\r\n    return fiberTree;\r\n}\r\nexports.createFiberTree = createFiberTree;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myJsx/createFiberTree.js?");

/***/ }),

/***/ "./myReact/js/myJsx/tplToVnode.js":
/*!****************************************!*\
  !*** ./myReact/js/myJsx/tplToVnode.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.tplToVDOM = void 0;\r\n//! 字符串扫描解析器\r\nclass Scanner {\r\n    constructor(text) {\r\n        this.text = text;\r\n        // 指针\r\n        this.pos = 0;\r\n        // 尾巴  剩余字符\r\n        this.tail = text;\r\n    }\r\n    /**\r\n     * 路过指定内容\r\n     *\r\n     * @memberof Scanner\r\n     */\r\n    scan(tag) {\r\n        if (this.tail.indexOf(tag) === 0) {\r\n            // 直接跳过指定内容的长度\r\n            this.pos += tag.length;\r\n            // 更新tail\r\n            this.tail = this.text.substring(this.pos);\r\n        }\r\n    }\r\n    /**\r\n     * 让指针进行扫描，直到遇见指定内容，返回路过的文字\r\n     *\r\n     * @memberof Scanner\r\n     * @return str 收集到的字符串\r\n     */\r\n    scanUntil(stopTag) {\r\n        // 记录开始扫描时的初始值\r\n        const startPos = this.pos;\r\n        // 当尾巴的开头不是stopTg的时候，说明还没有扫描到stopTag\r\n        while (!this.eos() && this.tail.indexOf(stopTag) !== 0) {\r\n            // 改变尾巴为当前指针这个字符到最后的所有字符\r\n            this.tail = this.text.substring(++this.pos);\r\n        }\r\n        // 返回经过的文本数据\r\n        return this.text.substring(startPos, this.pos).trim();\r\n    }\r\n    /**\r\n     * 判断指针是否到达文本末尾（end of string）\r\n     *\r\n     * @memberof Scanner\r\n     */\r\n    eos() {\r\n        return this.pos >= this.text.length;\r\n    }\r\n}\r\n//! 拆分html中的属性  (键值对)\r\nfunction propsParser(propsStr) {\r\n    const propsArr = propsStr.trim().split(' '); //[\"id='root'\", \"class='btn1'\"]\r\n    const props = {};\r\n    //! 将拆分好的kv数组转换成键值对放入props\r\n    propsArr.forEach(str => {\r\n        if (str.length > 3) { //!过滤空格和换行\r\n            //todo 解析key\r\n            const scanner = new Scanner(str);\r\n            let key = scanner.scanUntil('=');\r\n            const spaceIdx = key.indexOf(' ');\r\n            if (spaceIdx !== -1) {\r\n                const keys = key.replace(/\\s+/g, ' ').split(' ');\r\n                const len = keys.length;\r\n                for (let i = 0; i < len - 1; i++) {\r\n                    props[keys[i]] = true;\r\n                }\r\n                key = keys[len - 1].trim();\r\n            }\r\n            scanner.scan(\"=\"); //! 略过=符号  从下一位开始\r\n            let val = scanner.scanUntil('\"');\r\n            //todo 普通属性value解析\r\n            if (val[0] === \"'\") {\r\n                val = val.slice(1, val.length - 1); //去除多余的引号\r\n            }\r\n            //todo {{}}语法解析 获取挂载的方法 放入props\r\n            if (val[0] === '{' && val[1] === '{') {\r\n                val = val.slice(2, val.length - 2);\r\n                val = window['$' + val];\r\n            }\r\n            props[key] = val || true;\r\n            scanner.scan('\"');\r\n        }\r\n    });\r\n    return props;\r\n}\r\n//! 拆分html中的事件  (键值对)\r\nfunction eventParser(html) {\r\n    const jsEXP = /\\w*\\={{([\\s\\S]*?)}*}/;\r\n    let newHtml = html;\r\n    const event = {};\r\n    //todo 没有检测到事件直接退出\r\n    if (!jsEXP.test(html))\r\n        return { newHtml, event };\r\n    //TODO  循环拆离里面所有的JS语法 转换成键值对  \r\n    const kvArr = [];\r\n    let kv = [];\r\n    while (kv) {\r\n        kv = jsEXP.exec(newHtml);\r\n        if (kv) {\r\n            kvArr.push(kv[0]);\r\n            newHtml = newHtml.replace(kv[0], '');\r\n        }\r\n    }\r\n    //todo 将键值对数组拆分保存到event对象中\r\n    kvArr.forEach((item) => {\r\n        //删去最后两个}} 根据={{拆分成key value\r\n        let newItem = item.slice(0, item.length - 2);\r\n        const arr = newItem.split('={{');\r\n        //todo 使用eval将函数字符串转化为可执行的函数\r\n        let val = eval(\"(\" + arr[1] + \")\");\r\n        event[arr[0]] = val;\r\n    });\r\n    return { newHtml, event };\r\n}\r\n//! 将html模板字符串转换成tokens数组\r\nfunction collectTokens(html) {\r\n    const scanner = new Scanner(html);\r\n    const tokens = [];\r\n    let word = '';\r\n    while (!scanner.eos()) {\r\n        // 扫描文本\r\n        const text = scanner.scanUntil('<');\r\n        scanner.scan('<');\r\n        tokens[tokens.length - 1] && tokens[tokens.length - 1].push(text);\r\n        // 扫描标签<>中的内容\r\n        word = scanner.scanUntil('>');\r\n        scanner.scan('>');\r\n        // 如果没有扫描到值，就跳过本次进行下一次扫描\r\n        if (!word)\r\n            continue;\r\n        //todo 对本次扫描的字符串进行事件处理\r\n        const { newHtml, event } = eventParser(word); //todo 拆分事件\r\n        word = newHtml;\r\n        // 区分开始标签 # 和结束标签 /\r\n        if (word.startsWith('/')) {\r\n            tokens.push(['/', word.slice(1)]);\r\n        }\r\n        else {\r\n            //todo 如果有属性存在，则解析属性 (且将event添加进去)\r\n            const firstSpaceIdx = word.indexOf(' ');\r\n            if (firstSpaceIdx === -1) {\r\n                tokens.push(['#', word, Object.assign({}, event),]);\r\n            }\r\n            else {\r\n                // 解析属性\r\n                const propsStr = word.slice(firstSpaceIdx);\r\n                const data = propsParser(propsStr) || {};\r\n                tokens.push(['#', word.slice(0, firstSpaceIdx), Object.assign(Object.assign({}, data), event)]);\r\n            }\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\n//! 将tokens数组形成dom树形结构\r\nfunction nestTokens(tokens) {\r\n    const nestedTokens = [];\r\n    const stack = [];\r\n    let collector = nestedTokens;\r\n    for (let i = 0, len = tokens.length; i < len; i++) {\r\n        const token = tokens[i];\r\n        switch (token[0]) {\r\n            case '#':\r\n                // 收集当前token\r\n                collector.push(token);\r\n                // 压入栈中\r\n                stack.push(token);\r\n                // 由于进入了新的嵌套结构，新建一个数组保存嵌套结构\r\n                // 并修改collector的指向\r\n                token.splice(2, 0, []);\r\n                collector = token[2];\r\n                break;\r\n            case '/':\r\n                // 出栈\r\n                stack.pop();\r\n                // 将收集器指向上一层作用域中用于存放嵌套结构的数组\r\n                collector = stack.length > 0\r\n                    ? stack[stack.length - 1][2]\r\n                    : nestedTokens;\r\n                break;\r\n            default:\r\n                collector.push(token);\r\n        }\r\n    }\r\n    return nestedTokens;\r\n}\r\n//! 将tokens树转化为虚拟dom树\r\nfunction tokens2vdom(tokens) {\r\n    const vdom = {};\r\n    for (let i = 0, len = tokens.length; i < len; i++) {\r\n        const token = tokens[i];\r\n        vdom['tag'] = token[1];\r\n        vdom['props'] = token[3];\r\n        if (token[4]) {\r\n            vdom['text'] = token[token.length - 1];\r\n        }\r\n        else {\r\n            vdom['text'] = undefined;\r\n        }\r\n        const children = token[2];\r\n        if (children.length === 0) {\r\n            vdom['children'] = undefined;\r\n            continue;\r\n        }\r\n        ;\r\n        vdom['children'] = [];\r\n        for (let j = 0; j < children.length; j++) {\r\n            vdom['children'].push(tokens2vdom([children[j]]));\r\n        }\r\n        if (vdom['children'].length === 0) {\r\n            delete vdom['children'];\r\n        }\r\n    }\r\n    return vdom;\r\n}\r\n//! 总和方法 转换html模板为虚拟dom\r\nfunction tplToVDOM(html) {\r\n    const tokensArr = collectTokens(html);\r\n    const tokensTree = nestTokens(tokensArr);\r\n    const vdom = tokens2vdom(tokensTree);\r\n    return vdom;\r\n}\r\nexports.tplToVDOM = tplToVDOM;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myJsx/tplToVnode.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"myUseEffect\": () => (/* reexport safe */ _myReact_js_myHook_useEffect__WEBPACK_IMPORTED_MODULE_1__.myUseEffect),\n/* harmony export */   \"myUseState\": () => (/* reexport safe */ _myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_2__.myUseState),\n/* harmony export */   \"render\": () => (/* reexport safe */ _myReact_js_myHook_render__WEBPACK_IMPORTED_MODULE_0__.render)\n/* harmony export */ });\n/* harmony import */ var _myReact_js_myHook_render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../myReact/js/myHook/render */ \"./myReact/js/myHook/render.js\");\n/* harmony import */ var _myReact_js_myHook_useEffect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../myReact/js/myHook/useEffect */ \"./myReact/js/myHook/useEffect.js\");\n/* harmony import */ var _myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../myReact/js/myHook/useState */ \"./myReact/js/myHook/useState.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 渲染app\r\n// const app = render(App, document.getElementById('root'))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://myreact/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;