/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./myReact/js/myHook/GlobalFiber.js":
/*!******************************************!*\
  !*** ./myReact/js/myHook/GlobalFiber.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.updateWorkInProgressHook = exports.global = void 0;\r\n//todo ------------------全局使用的结构和变量 方法-----------------------------\r\n//! --------组件对应的fiber---------------------\r\nlet iniFiber = {\r\n    memorizedState: null,\r\n    stateNode: () => { },\r\n    updateQueue: null,\r\n    fiberFlags: 'mount',\r\n    hasRef: false,\r\n    ref: null,\r\n    children: [],\r\n    props: null,\r\n    tag: null,\r\n    text: null,\r\n    sourcePool: null,\r\n    hookIndex: 0 // 用于记录hook的数量 以便查找\r\n};\r\n//! -----需要使用的全局变量---------------\r\nconst global = {\r\n    rootFiber: iniFiber,\r\n    workInProgressHook: { currentHook: null },\r\n    currentFiberNode: iniFiber,\r\n    destoryEffectsArr: [],\r\n    renderTag: 'mount' // 用于判断是否是首次更新\r\n};\r\nexports.global = global;\r\n//! ----------拿取需要本次update需要更新的hook----------------------\r\nfunction updateWorkInProgressHook(fiber) {\r\n    let index = fiber.hookIndex;\r\n    let currentHook = fiber.memorizedState;\r\n    while (currentHook && currentHook.index != index) {\r\n        currentHook = currentHook.next;\r\n    }\r\n    // 因为链表是按顺序的 所以这个函数每执行一次就新增一个\r\n    fiber.hookIndex += 1;\r\n    return currentHook;\r\n}\r\nexports.updateWorkInProgressHook = updateWorkInProgressHook;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/GlobalFiber.js?");

/***/ }),

/***/ "./myReact/js/myHook/render.js":
/*!*************************************!*\
  !*** ./myReact/js/myHook/render.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.unmountPart = exports.commitPart = exports.resetFiber = exports.updateRender = exports.render = void 0;\r\n//! render分为2部分  render阶段 - commit阶段  最后unmount\r\nconst GlobalFiber_1 = __webpack_require__(/*! ./GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\nconst createFiberTree_1 = __webpack_require__(/*! ../myJsx/createFiberTree */ \"./myReact/js/myJsx/createFiberTree.js\");\r\n//! ----------------模拟render部分------------------------\r\n//! 更改并生成fiber树  (结束后fiber由mount变为update)\r\nfunction renderPart(functionComponent) {\r\n    //todo 首次执行App函数\r\n    const { template, resource, rootFiberNode } = firstRenderApp(functionComponent);\r\n    //todo根据组件构建fiberTree(首次)\r\n    const fiberTree = (0, createFiberTree_1.createFiberTree)(template, resource);\r\n    rootFiberNode.children.push(fiberTree);\r\n    return rootFiberNode;\r\n}\r\n//todo 获取上一次的fiberTree 执行所有打上tag的functionComponent进行state更新 再commit   \r\nfunction updateRenderPart(functionComponent, rootFiber) {\r\n    // 改变tag\r\n    GlobalFiber_1.global.renderTag = 'update';\r\n    // 处理根App节点\r\n    const { template, resource, rootFiberNode } = firstUpdateRenderApp(functionComponent, rootFiber);\r\n    // 更新函数组件(因为处理了根节点 从根节点的第一个子节点开始递归)\r\n    const secondNode = rootFiberNode.children[0];\r\n    // 此时不需要创建fiberNode  所以不需要添加childFiber  直接在根fiber树上更新\r\n    (0, createFiberTree_1.updateFiberTree)(template, secondNode, resource);\r\n    return rootFiberNode;\r\n}\r\n//对render根Fiber节点进行处理(否则无法渲染第一个根节点)\r\nfunction firstRenderApp(functionComponent) {\r\n    const rootFiberNode = GlobalFiber_1.global.rootFiber;\r\n    GlobalFiber_1.global.currentFiberNode = rootFiberNode;\r\n    rootFiberNode.stateNode = functionComponent;\r\n    //! 用于解决webpack 函数名出现bound问题\r\n    const functionNameArr = functionComponent.name.split(' ');\r\n    let functionName = functionNameArr[0] === 'bound'\r\n        ? functionNameArr[1]\r\n        : functionNameArr[0];\r\n    rootFiberNode.tag = functionName;\r\n    const { template, data, components } = functionComponent();\r\n    const resource = { data, components };\r\n    rootFiberNode.fiberFlags = 'update';\r\n    return { template, resource, rootFiberNode };\r\n}\r\nfunction firstUpdateRenderApp(functionComponent, fiber) {\r\n    const rootFiberNode = fiber;\r\n    GlobalFiber_1.global.currentFiberNode = rootFiberNode;\r\n    rootFiberNode.stateNode = functionComponent;\r\n    //! 用于解决webpack 函数名出现bound问题\r\n    const functionNameArr = functionComponent.name.split(' ');\r\n    let functionName = functionNameArr[0] === 'bound'\r\n        ? functionNameArr[1]\r\n        : functionNameArr[0];\r\n    rootFiberNode.tag = functionName;\r\n    const { template, data, components } = functionComponent();\r\n    const resource = { data, components };\r\n    rootFiberNode.fiberFlags = 'update';\r\n    return { template, resource, rootFiberNode };\r\n}\r\n//! -----------------模拟Commit阶段-----------------------------\r\n//! 分为三部分  beforeMutation  mutation  layout阶段\r\n//! before 前置处理  mutation 渲染dom节点   layout  处理useEffect useLayoutEffect\r\nfunction commitPart(fiber, rootDom) {\r\n    console.log('本次commit的fiber', fiber);\r\n    //todo  mutation阶段\r\n    removeHtml(rootDom);\r\n    createHtml(fiber, rootDom); //根据fiberTree创建html\r\n    //! 这里为了简化重新render  将root节点挂载上去了  需要更正\r\n    fiber.ref = rootDom; //挂载ref\r\n    //todo  layout阶段  调用Effects链表 执行create函数()\r\n    handleEffect(fiber);\r\n    //todo 处理ref\r\n    if (fiber.hasRef) {\r\n        // commitAttachRef()//绑定ref\r\n    }\r\n}\r\nexports.commitPart = commitPart;\r\n//! 清空子节点 换nodeList为数组 再循环清空\r\nfunction removeHtml(rootDom) {\r\n    //转换nodeList为数组\r\n    const childDomArr = [].slice.apply(rootDom.childNodes);\r\n    childDomArr.forEach((dom) => {\r\n        rootDom.removeChild(dom);\r\n    });\r\n}\r\n//! (从更新的rootDom处开始)根据fiberTree创建html\r\nfunction createHtml(fiber, rootDom) {\r\n    //不同的tag标签创建不同的html标签\r\n    let dom = document.createElement(fiber.tag);\r\n    //todo 如果是组件节点   挂载ref \r\n    if (fiber.tag[0] === fiber.tag[0].toUpperCase()) {\r\n        dom = document.createElement('fc-' + fiber.tag);\r\n        fiber.ref = dom;\r\n        //todo 如果是小写 判断为html标签 填充文本 处理属性\r\n    }\r\n    else {\r\n        handleProps(fiber, dom);\r\n        if (fiber.text) {\r\n            dom.innerHTML = fiber.text;\r\n        }\r\n    }\r\n    //todo 深度优先递归children 从dom开始渲染子dom节点 \r\n    fiber.children.forEach((fiber) => {\r\n        createHtml(fiber, dom);\r\n    });\r\n    rootDom.appendChild(dom);\r\n}\r\n//! 对标签中的属性进行处理 给dom节点添加标签 (未完成)\r\nfunction handleProps(curFiber, dom) {\r\n    const props = curFiber.props;\r\n    for (let key in props) {\r\n        const value = props[key];\r\n        switch (key) {\r\n            //todo  处理className (合并所有的类名)\r\n            case 'className':\r\n                let classNameStr = '';\r\n                for (let i = 0; i < value.length; i++) {\r\n                    classNameStr += value[i] + ' ';\r\n                }\r\n                dom.setAttribute(\"class\", classNameStr.trim());\r\n                break;\r\n            //todo  处理class (合并所有的类名)\r\n            case 'class':\r\n                let classStr = '';\r\n                for (let i = 0; i < value.length; i++) {\r\n                    classStr += value[i] + ' ';\r\n                }\r\n                dom.setAttribute(\"class\", classStr.trim());\r\n                break;\r\n            //todo  处理点击事件\r\n            case 'onClick':\r\n                //! 从组件的资源池里找对应的事件\r\n                const dataPool = curFiber.sourcePool.data;\r\n                const callback = dataPool[value[0]];\r\n                dom.addEventListener(\"click\", callback);\r\n                break;\r\n            //todo  处理其他\r\n            default:\r\n                dom.setAttribute(key, value[0]);\r\n                break;\r\n        }\r\n    }\r\n}\r\n//! 遍历树获取所有的Effect(执行create和生成destory函数数组)\r\nfunction handleEffect(fiber) {\r\n    let destoryEffectsArr = [];\r\n    if (fiber.updateQueue) {\r\n        const createEffectsArr = createCallbackQueue(fiber);\r\n        destoryEffectsArr = doCreateQueue(createEffectsArr);\r\n    }\r\n    if (fiber.children.length !== 0) {\r\n        fiber.children.forEach((fiber) => {\r\n            handleEffect(fiber);\r\n        });\r\n    }\r\n    GlobalFiber_1.global.destoryEffectsArr.push(...destoryEffectsArr);\r\n}\r\n//todo 遍历Effect链表 将需要执行的Effect推入数组--------------\r\nfunction createCallbackQueue(fiber) {\r\n    const createEffectsArr = [];\r\n    const lastEffect = fiber.updateQueue.lastEffect;\r\n    const firstEffect = lastEffect.next;\r\n    let currentEffect = firstEffect;\r\n    do {\r\n        //判断effectTag决定是否执行Effect(mount和dep变更时执行)\r\n        //React底层通过二进制来打tag\r\n        const isFiberMount = Boolean(GlobalFiber_1.global.renderTag === 'mount');\r\n        const isDepChange = Boolean(currentEffect.tag === 'depChanged');\r\n        const isNullDeps = Boolean(currentEffect.tag === 'nullDeps');\r\n        const isNoDeps = Boolean(currentEffect.tag === 'noDeps');\r\n        //根据不同情况 将Effect推入数组  达到不同的useEffect的效果\r\n        if (isFiberMount || isDepChange || isNullDeps) {\r\n            createEffectsArr.push(currentEffect);\r\n        }\r\n        else if (isFiberMount && isNoDeps) {\r\n            createEffectsArr.push(currentEffect);\r\n        }\r\n        currentEffect = currentEffect.next;\r\n    } while (currentEffect !== firstEffect);\r\n    return createEffectsArr;\r\n}\r\n//todo 遍历执行需要执行的Effect---生成destory---------\r\nfunction doCreateQueue(createEffectsArr) {\r\n    const destoryEffectsArr = [];\r\n    //todo 遍历Effects数组 执行create  \r\n    //todo 生成destoryEffect数组 将destory存放到对应的Effect上\r\n    for (let i = 0; i < createEffectsArr.length; i++) {\r\n        const destory = createEffectsArr[i].create(); // 执行create\r\n        if (destory) {\r\n            createEffectsArr[i].destory = destory; // 赋值destory\r\n            destoryEffectsArr.push(createEffectsArr[i]); //推入destory数组\r\n        }\r\n    }\r\n    return destoryEffectsArr;\r\n}\r\n//! ----------模拟unmount阶段 -------------------------\r\n//todo  清空上一次执行完的updateQueue 重置HookIndex 执行distory函数数组\r\nfunction unmountPart() {\r\n    doDestoryQueue(GlobalFiber_1.global.destoryEffectsArr);\r\n    resetFiber(GlobalFiber_1.global.rootFiber);\r\n}\r\nexports.unmountPart = unmountPart;\r\n//todo -----在unmounted时执行destorys数组\r\nfunction doDestoryQueue(destoryEffectsArr) {\r\n    for (let i = 0; i < destoryEffectsArr.length; i++) {\r\n        const destory = destoryEffectsArr[i].destory;\r\n        if (destory) {\r\n            destory();\r\n        }\r\n    }\r\n}\r\n//todo ----遍历清空fiber树上的hookIndex 和 queue\r\nfunction resetFiber(fiberTree) {\r\n    fiberTree.hookIndex = 0;\r\n    fiberTree.updateQueue = null;\r\n    GlobalFiber_1.global.destoryEffectsArr = [];\r\n    if (fiberTree.children.length !== 0) {\r\n        fiberTree.children.forEach((fiber) => {\r\n            resetFiber(fiber);\r\n        });\r\n    }\r\n}\r\nexports.resetFiber = resetFiber;\r\n//!--------------综合Render方法-------------------\r\nfunction render(functionComponent, rootDom) {\r\n    console.log('------------render-------------');\r\n    const fiber = renderPart(functionComponent); //todo render阶段\r\n    commitPart(fiber, rootDom); //todo commit阶段\r\n    unmountPart(); //todo unmount阶段\r\n}\r\nexports.render = render;\r\nfunction updateRender(functionComponent, rootDom, rootFiber) {\r\n    console.log('------------updateRender-------------');\r\n    const newFiber = updateRenderPart(functionComponent, rootFiber);\r\n    commitPart(newFiber, rootDom); //todo commit阶段\r\n    unmountPart(); //todo unmount阶段\r\n}\r\nexports.updateRender = updateRender;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/render.js?");

/***/ }),

/***/ "./myReact/js/myHook/useEffect.js":
/*!****************************************!*\
  !*** ./myReact/js/myHook/useEffect.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.myUseEffect = void 0;\r\n//修改全局变量的方法\r\nconst GlobalFiber_1 = __webpack_require__(/*! ./GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\n//! -------mountEffect(useEffect第一次执行)-------------\r\nfunction mountEffect(fiberFlags, hookFlags, create, deps) {\r\n    //todo 创建Hook 成为fiber.memorizedState上的一项Hook (单向链表)\r\n    const hook = mountWorkInProgressHook();\r\n    //判断是否传入deps 不同时机执行useEffect\r\n    const nextDeps = deps === undefined ? null : deps;\r\n    //! 根据deps传入不同的情况  实现useEffect的不同使用\r\n    //此时memorizedState保存的就是最后更新的Effect数据(第一次destory为undefined)\r\n    if (nextDeps === null) {\r\n        hook.memorizedState = pushEffect('nullDeps', create, undefined, nextDeps);\r\n    }\r\n    else if (nextDeps.length === 0) {\r\n        hook.memorizedState = pushEffect('noDeps', create, undefined, nextDeps);\r\n    }\r\n    else {\r\n        hook.memorizedState = pushEffect('depNoChange', create, undefined, nextDeps);\r\n    }\r\n    //todo mount后 hookFlag变为update\r\n    hook.hookFlags = 'update';\r\n}\r\n//! --------创建一个Hook 形成环链表 添加到hook队列--------------\r\nfunction mountWorkInProgressHook() {\r\n    const fiber = GlobalFiber_1.global.currentFiberNode; //! 测试\r\n    //todo 新建一个hook\r\n    const newHook = {\r\n        index: 0,\r\n        memorizedState: null,\r\n        hookFlags: 'mount',\r\n        next: null\r\n    };\r\n    // 添加Hook进单向链表\r\n    if (fiber.memorizedState !== null) {\r\n        const lastHook = fiber.memorizedState;\r\n        newHook.index = lastHook.index + 1;\r\n        newHook.next = lastHook;\r\n        fiber.memorizedState = newHook;\r\n    }\r\n    //接入hook到fiber上\r\n    fiber.memorizedState = newHook;\r\n    //接入hook到workProgress\r\n    GlobalFiber_1.global.workInProgressHook.currentHook = newHook;\r\n    return newHook;\r\n}\r\n//! -------updateEffect(useEffect后续更新)-------------\r\nfunction updateEffect(fiberFlags, hookFlags, create, deps) {\r\n    const fiber = GlobalFiber_1.global.currentFiberNode; //! 测试\r\n    const currentHook = (0, GlobalFiber_1.updateWorkInProgressHook)(fiber);\r\n    //判断是否传入deps 不同时机执行useEffect\r\n    const nextDeps = deps === undefined ? null : deps;\r\n    //!执行updateEffect 改变fiberFlages\r\n    //! fiber.fiberFlags = fiberFlags\r\n    //todo  如果有currentHook 获得上一次执行create返回的的销毁函数\r\n    if (currentHook !== null) {\r\n        const prevEffect = currentHook.memorizedState; //最后一次Effect\r\n        //todo update时从上一次的Effect中取出销毁函数(在commit阶段执行create函数并赋值了destory)\r\n        const destory = prevEffect.destory;\r\n        //! 根据传入的dep 判断是否执行effect\r\n        //注意 无论如何都会推入Effect  \r\n        if (nextDeps !== null) {\r\n            //todo 浅比较上次和本次的deps是否相等  传入不同的tag  用于减少更新\r\n            const prveDeps = prevEffect.deps;\r\n            if (shallowCompareDeps(nextDeps, prveDeps)) {\r\n                pushEffect('depNoChange', create, destory, nextDeps);\r\n                return;\r\n            }\r\n            //todo 如果deps发生改变  传入的tag为'depChanged' commit时这个Effects才会被执行\r\n            //todo  (执行的最后一个effect要被赋值给memorizedState)\r\n            else {\r\n                currentHook.memorizedState =\r\n                    pushEffect('depChanged', create, destory, nextDeps);\r\n            }\r\n        }\r\n        //! 如果没有传deps 表示任意时候都执行\r\n        if (nextDeps === null) {\r\n            pushEffect('nullDeps', create, undefined, nextDeps);\r\n        }\r\n    }\r\n}\r\n//! ------浅比较前后deps是否发生变化-------------------\r\nfunction shallowCompareDeps(nextDeps, prveDeps) {\r\n    //todo console.log('前后dep对比', prveDeps, nextDeps);\r\n    // 选取最大的lenght\r\n    const length = nextDeps.length > prveDeps.length ? nextDeps.length : prveDeps.length;\r\n    let res = true;\r\n    for (let i = 0; i < length; i++) {\r\n        if (nextDeps[i] !== prveDeps[i])\r\n            return res = false;\r\n    }\r\n    return res;\r\n}\r\n//! --------pushEffect创建/增加Effects更新链表---------------\r\nfunction pushEffect(tag, create, destory, deps) {\r\n    const fiber = GlobalFiber_1.global.currentFiberNode; //! 测试\r\n    // 创建Effect \r\n    const effect = {\r\n        tag,\r\n        create,\r\n        destory,\r\n        deps,\r\n        next: null\r\n    };\r\n    //todo 如果Hook上没有更新链表  创建更新链表  如果有则插入一个effect到更新环链表尾部\r\n    const updateQueue = { lastEffect: null };\r\n    if (fiber.updateQueue === null) {\r\n        updateQueue.lastEffect = effect.next = effect; // 自身形成环状链表\r\n        //更新fiber上的updateQueue环链表\r\n        fiber.updateQueue = updateQueue;\r\n    }\r\n    else {\r\n        const lastEffect = fiber.updateQueue.lastEffect;\r\n        if (lastEffect === null) { //todo 有链表结构但是链表为空\r\n            updateQueue.lastEffect = effect.next = effect; // 自身形成环状链表\r\n        }\r\n        else { // todo 插入effect到环链表尾端\r\n            const firstEffect = lastEffect.next;\r\n            lastEffect.next = effect;\r\n            effect.next = firstEffect;\r\n            updateQueue.lastEffect = effect; //此时环链表上的最后一项就是effect\r\n            //更新fiber上的updateQueue环链表\r\n            fiber.updateQueue = updateQueue;\r\n        }\r\n    }\r\n    //todo 返回这个Effect 会被赋值给hook.memorizedState(最后一次更新的状态)\r\n    return effect;\r\n}\r\n//!------------useEffect主体--------------\r\nfunction myUseEffect(create, deps) {\r\n    const nextDeps = deps === undefined ? null : deps;\r\n    const fiber = GlobalFiber_1.global.currentFiberNode; //! 测试\r\n    // 第一次useEffect执行mountEffect\r\n    if (fiber.fiberFlags === 'mount') {\r\n        const hookFlags = 'mount';\r\n        mountEffect('mount', hookFlags, create, nextDeps);\r\n        // 后续useEffect执行updateEffect\r\n    }\r\n    else if (fiber.fiberFlags === 'update') {\r\n        const hookFlags = 'update';\r\n        updateEffect('update', hookFlags, create, nextDeps);\r\n    }\r\n}\r\nexports.myUseEffect = myUseEffect;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/useEffect.js?");

/***/ }),

/***/ "./myReact/js/myHook/useState.js":
/*!***************************************!*\
  !*** ./myReact/js/myHook/useState.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.myUseState = void 0;\r\nconst render_1 = __webpack_require__(/*! ./render */ \"./myReact/js/myHook/render.js\");\r\n// 全局变量和当前 Fiber\r\nconst GlobalFiber_1 = __webpack_require__(/*! ./GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\n//! ---------------useState返回的updater方法(updateState方法)-------------------\r\nfunction dispatchAction(queue, curFiber, newVal, action) {\r\n    //创建updater环链表\r\n    const updater = {\r\n        action: newVal || action,\r\n        next: null\r\n    };\r\n    //pending上没有updater 自己形成环状链表  ; 有updater链表  插入一个updater\r\n    if (queue.pending === null) {\r\n        updater.next = updater;\r\n    }\r\n    else {\r\n        updater.next = queue.pending.next;\r\n        queue.pending.next = updater;\r\n    }\r\n    // 让此updater成为lastUpdater\r\n    queue.pending = updater;\r\n    //! 从当前fiber节点开始 重新render组件  这里需要调用unmount生命周期钩子\r\n    //! 源码中使用切换fiber树的方式执行重新渲染 不需要执行生命周期(处理fiber树时变相执行了unmount阶段)\r\n    //! 从当前fiber节点  重新执行函数式组件  更新子fiber树\r\n    //! (需要传入当前fiber进行递归)\r\n    (0, render_1.resetFiber)(curFiber);\r\n    //todo 多个setState会触发多个render  实际上会将多个setState合并执行\r\n    (0, render_1.updateRender)(curFiber.stateNode, curFiber.ref, curFiber);\r\n}\r\n//! 创建一个useStateHook并添加到链表中------------------------\r\nfunction createHook(initialState) {\r\n    const fiber = GlobalFiber_1.global.currentFiberNode; //! 测试\r\n    // 创建useState类型的hook\r\n    const hook = {\r\n        hookFlags: 'mount',\r\n        index: fiber.memorizedState ? fiber.memorizedState.index + 1 : 0,\r\n        memorizedState: initialState,\r\n        updateStateQueue: { pending: null },\r\n        next: null\r\n    };\r\n    // 将hook添加到fiber上,且将hook链接到全局hooks链表上  成为last项\r\n    if (!fiber.memorizedState) {\r\n        GlobalFiber_1.global.workInProgressHook.currentHook = hook;\r\n    }\r\n    else {\r\n        const lastEffect = fiber.memorizedState;\r\n        hook.next = lastEffect;\r\n    }\r\n    GlobalFiber_1.global.workInProgressHook.currentHook = hook;\r\n    fiber.memorizedState = hook;\r\n    return hook;\r\n}\r\n//! 更新该Hook的memorizedState-----------------------------\r\nfunction updateUseStateHook(hook) {\r\n    // 取出更新链表上的最后一个state\r\n    let baseState = hook.memorizedState;\r\n    //pending保存了链表最后一项   next就指向第一个update\r\n    if (hook.updateStateQueue.pending) {\r\n        let firstUpdate = hook.updateStateQueue.pending.next;\r\n        // queue链表 执行update(执行update上的action(update传入的参数 num=>num+1))  \r\n        do {\r\n            const action = firstUpdate.action;\r\n            //todo 更新baseState 分为传入函数和传入newValue两种情况\r\n            baseState = typeof action === 'function'\r\n                ? action(baseState)\r\n                : action;\r\n            firstUpdate = firstUpdate.next; // 链表后移\r\n            // 终止遍历链表\r\n        } while (firstUpdate !== hook.updateStateQueue.pending.next);\r\n        // 清空state更新链表\r\n        hook.updateStateQueue.pending = null;\r\n    }\r\n    // 遍历结束 将更新后的baseState存放到hook.memorizedState上\r\n    hook.memorizedState = baseState;\r\n    return baseState;\r\n}\r\n//! ----------执行useState会执行state的计算过程----------------\r\nfunction myUseState(initialState) {\r\n    //todo  需要找到当前的fiber节点()\r\n    let fiber = GlobalFiber_1.global.currentFiberNode;\r\n    //取出当前hook 如果是mount阶段就创建一个hook(初始值为initState)\r\n    let hook;\r\n    if (fiber.fiberFlags === 'mount') {\r\n        hook = createHook(initialState); //创建hook 添加到hook链表\r\n    }\r\n    else {\r\n        // 更新情况 找到对应的hook\r\n        hook = (0, GlobalFiber_1.updateWorkInProgressHook)(fiber);\r\n    }\r\n    //todo 更新hook上保存的state\r\n    const baseState = updateUseStateHook(hook);\r\n    //todo 执行完useState 钩子状态变为update\r\n    hook.hookFlags = 'update';\r\n    //todo 返回最新的状态 和updateAction \r\n    //todo bind本次useState的fiber节点 用于从当前组件开始更新\r\n    return [baseState, dispatchAction.bind(null, hook.updateStateQueue, fiber)];\r\n}\r\nexports.myUseState = myUseState;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myHook/useState.js?");

/***/ }),

/***/ "./myReact/js/myJsx/createFiberTree.js":
/*!*********************************************!*\
  !*** ./myReact/js/myJsx/createFiberTree.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.updateFiberTree = exports.createFiberTree = void 0;\r\nconst tplToVnode_1 = __webpack_require__(/*! ./tplToVnode */ \"./myReact/js/myJsx/tplToVnode.js\");\r\nconst GlobalFiber_1 = __webpack_require__(/*! ../myHook/GlobalFiber */ \"./myReact/js/myHook/GlobalFiber.js\");\r\n//! 创建fiberNode树(Vnode树)\r\n//! 深度优先遍历vnode树  包装成fiberNode\r\n//! 根据fiberNode和FunctionComponent创建FiberNode 生成Fiber树\r\nfunction createFiberTree(source, resources) {\r\n    //todo 创建一个新的fiber节点 \r\n    let newFiberTree = {\r\n        memorizedState: null,\r\n        stateNode: () => { },\r\n        updateQueue: null,\r\n        fiberFlags: 'mount',\r\n        hasRef: false,\r\n        ref: null,\r\n        children: [],\r\n        props: null,\r\n        tag: null,\r\n        text: null,\r\n        sourcePool: null,\r\n        hookIndex: 0 // 用于记录hook的数量 以便查找\r\n    };\r\n    //todo 当前工作节点变为这个\r\n    GlobalFiber_1.global.currentFiberNode = newFiberTree;\r\n    //todo 判断传入的source 转换成vnode\r\n    let vnode = typeof source === 'string'\r\n        ? (0, tplToVnode_1.tplToVDOM)(source)\r\n        : source;\r\n    //合并vnode和Fiber 挂载resource\r\n    const { children = [], props, tag, text } = vnode;\r\n    newFiberTree.props = props;\r\n    newFiberTree.tag = tag;\r\n    newFiberTree.text = text;\r\n    newFiberTree.sourcePool = resources;\r\n    //TODO -----------如果tag大写 解析为组件 ----------------\r\n    if (tag[0] === tag[0].toUpperCase()) {\r\n        //todo 从sourcePool中获取子组件\r\n        const fc = newFiberTree.sourcePool.components[tag];\r\n        if (!fc) {\r\n            console.error(`子组件${tag}未注册`);\r\n        }\r\n        //! 从资源池中拿取需要的props，给子函数组件绑定需要的props,并挂载子函数组件到fiber上\r\n        handleFunctionComponentProps(newFiberTree, fc);\r\n        //! 需要在这里执行fc 挂载hooks 生成新的resource\r\n        const { template, data = {}, components = {} } = newFiberTree.stateNode();\r\n        const resources = { data, components };\r\n        // ! 渲染组件子fiber树 (sourcePool仅保存了父组件返回的数据)   \r\n        const childFiber = createFiberTree(template, resources);\r\n        newFiberTree.children = [childFiber];\r\n    }\r\n    //TODO ------------单fiber节点处理结束  更改flag\r\n    newFiberTree.fiberFlags = 'update';\r\n    //todo 如果有children 深度优先遍历  包装成fiberNode 挂到当前节点\r\n    if (children) {\r\n        for (let i = 0; i < children.length; i++) {\r\n            const childFiberTree = createFiberTree(children[i], newFiberTree.sourcePool);\r\n            newFiberTree.children.push(childFiberTree);\r\n        }\r\n    }\r\n    return newFiberTree;\r\n}\r\nexports.createFiberTree = createFiberTree;\r\n//! ---------------更新fiberTree-------------------\r\nfunction updateFiberTree(source, fiber, resources) {\r\n    //todo 判断传入的source 转换成vnode\r\n    let vnode = typeof source === 'string'\r\n        ? (0, tplToVnode_1.tplToVDOM)(source)\r\n        : source;\r\n    //todo 赋值当前正在工作的fiber节点\r\n    const currentFiber = GlobalFiber_1.global.currentFiberNode = fiber;\r\n    //todo 合并vnode和当前fiber\r\n    let { children = [], props, tag, text } = vnode;\r\n    currentFiber.props = props;\r\n    currentFiber.tag = tag;\r\n    currentFiber.text = text;\r\n    currentFiber.sourcePool = resources; //挂载事件资源\r\n    //TODO -----------如果tag大写 解析为组件 ----------------\r\n    if (tag[0] == tag[0].toUpperCase()) {\r\n        //todo 从sourcePool中获取子组件\r\n        const fc = currentFiber.sourcePool.components[tag];\r\n        //! 给子函数组件绑定需要的props\r\n        //! (注意这里的props是上一个组件传递来的数据  上面的props是tag上的属性)\r\n        handleFunctionComponentProps(currentFiber, fc);\r\n        //! 需要在这里执行fc 挂载hooks\r\n        const { template, data = {}, components = {} } = currentFiber.stateNode();\r\n        const resources = { data, components };\r\n        // ! 渲染组件子fiber树 挂载resources(需修改)\r\n        currentFiber.sourcePool = resources;\r\n        const childVnode = (0, tplToVnode_1.tplToVDOM)(template);\r\n        children.unshift(childVnode);\r\n    }\r\n    //todo 如果有children 深度优先遍历  \r\n    if (children) {\r\n        for (let i = 0; i < children.length; i++) {\r\n            //! 当map添加item时  可能造成vnode和childrenFiber数量不等\r\n            //! 如果发现没有此fiber 就再根据vnode创建一个fiber\r\n            const vnode = children[i];\r\n            const resources = currentFiber.sourcePool;\r\n            const childFiber = currentFiber.children[i] || createFiberTree(vnode, resources);\r\n            currentFiber.children[i] = updateFiberTree(vnode, childFiber, resources);\r\n        }\r\n    }\r\n    return currentFiber;\r\n}\r\nexports.updateFiberTree = updateFiberTree;\r\n//! ------------从资源池中拿取子组件需要的Props 处理后传递给子组件----------\r\n//! 返回处理好的子组件函数传递出去\r\nfunction handleFunctionComponentProps(fiber, functionComponent) {\r\n    const needProps = fiber.props;\r\n    const data = fiber.sourcePool.data;\r\n    const nextProps = {};\r\n    for (let key in needProps) {\r\n        let value = needProps[key][0];\r\n        //! 对传入的props进行数据类型解析\r\n        if (data[value]) { //从需求池中找到了对应的数据\r\n            nextProps[key] = data[value];\r\n        }\r\n        else if (!isNaN((value - 0))) { //传入数字\r\n            value = value - 0;\r\n            nextProps[key] = value;\r\n        }\r\n        else if (value[0] === '\"' || value[0] === \"'\") { //传入字符串\r\n            nextProps[key] = value.slice(1, value.length - 1).trim();\r\n        }\r\n        else { // 传入普通字符串\r\n            nextProps[key] = value;\r\n        }\r\n    }\r\n    //给函数组件绑定props  挂载到fiber上\r\n    const newFc = functionComponent.bind(null, nextProps);\r\n    fiber.stateNode = newFc;\r\n    return newFc;\r\n}\r\n// 错误记录\r\n// 函数name被webpack打包后会变为bound+函数名\r\n// 不能直接给tag赋值 \r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myJsx/createFiberTree.js?");

/***/ }),

/***/ "./myReact/js/myJsx/tplToVnode.js":
/*!****************************************!*\
  !*** ./myReact/js/myJsx/tplToVnode.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.tokens2vdom = exports.nestTokens = exports.collectTokens = exports.tplToVDOM = void 0;\r\n//! 字符串扫描解析器\r\nclass Scanner {\r\n    constructor(text) {\r\n        this.text = text;\r\n        // 指针\r\n        this.pos = 0;\r\n        // 尾巴  剩余字符\r\n        this.tail = text;\r\n    }\r\n    /**\r\n     * 路过指定内容\r\n     *\r\n     * @memberof Scanner\r\n     */\r\n    scan(tag) {\r\n        if (this.tail.indexOf(tag) === 0) {\r\n            // 直接跳过指定内容的长度\r\n            this.pos += tag.length;\r\n            // 更新tail\r\n            this.tail = this.text.substring(this.pos);\r\n        }\r\n    }\r\n    /**\r\n     * 让指针进行扫描，直到遇见指定内容，返回路过的文字\r\n     *\r\n     * @memberof Scanner\r\n     * @return str 收集到的字符串\r\n     */\r\n    scanUntil(stopTag) {\r\n        // 记录开始扫描时的初始值\r\n        const startPos = this.pos;\r\n        // 当尾巴的开头不是stopTg的时候，说明还没有扫描到stopTag\r\n        while (!this.eos() && this.tail.indexOf(stopTag) !== 0) {\r\n            // 改变尾巴为当前指针这个字符到最后的所有字符\r\n            this.tail = this.text.substring(++this.pos);\r\n        }\r\n        // 返回经过的文本数据\r\n        return this.text.substring(startPos, this.pos).trim();\r\n    }\r\n    /**\r\n     * 判断指针是否到达文本末尾（end of string）\r\n     *\r\n     * @memberof Scanner\r\n     */\r\n    eos() {\r\n        return this.pos >= this.text.length;\r\n    }\r\n}\r\n//! 拆分html中的事件  (键值对)\r\nfunction eventParser(html) {\r\n    const jsEXP = /\\w*\\={{([\\s\\S]*?)}*}/;\r\n    let newHtml = html;\r\n    const event = {};\r\n    //todo 没有检测到事件直接退出\r\n    if (!jsEXP.test(html))\r\n        return { newHtml, event };\r\n    //TODO  循环拆离里面所有的JS语法 转换成键值对  \r\n    const kvArr = [];\r\n    let kv = [];\r\n    while (kv) {\r\n        kv = jsEXP.exec(newHtml);\r\n        if (kv) {\r\n            kvArr.push(kv[0]);\r\n            newHtml = newHtml.replace(kv[0], '');\r\n        }\r\n    }\r\n    //todo 将键值对数组拆分保存到event对象中\r\n    kvArr.forEach((item) => {\r\n        //删去最后两个}} 根据={{拆分成key value\r\n        let newItem = item.slice(0, item.length - 2);\r\n        const arr = newItem.split('={{');\r\n        //todo 使用eval将函数字符串转化为可执行的函数\r\n        let val = eval(\"(\" + arr[1] + \")\");\r\n        event[arr[0]] = val;\r\n    });\r\n    return { newHtml, event };\r\n}\r\n//! 拆分html中的属性222  (键值对)\r\nfunction allPropsParser(html) {\r\n    //todo 正则适配\r\n    // const classEXP = /\\w*\\=\"([\\s\\S]*?)\"/\r\n    const classEXP = /[\\w-]*=\"([\\s\\S]*?)\"/; //! 包括横杠类名\r\n    const singleEXP = /\\w*\\='([\\s\\S]*?)'/;\r\n    const eventEXP = /\\w*\\={([\\s\\S]*?)}/;\r\n    //todo 将中间多个空格合并为一个\r\n    let newHtml2 = html.replace(/ +/g, ' ');\r\n    const props = {};\r\n    //todo 没有检测到事件直接退出\r\n    const hasProps = classEXP.test(html) || singleEXP.test(html) || eventEXP.test(html);\r\n    if (!hasProps)\r\n        return { newHtml2, props };\r\n    //TODO  循环拆离里面所有的JS语法 转换成键值对  \r\n    const kvArr = [];\r\n    let kv = [];\r\n    while (kv) {\r\n        kv = classEXP.exec(newHtml2) ||\r\n            singleEXP.exec(newHtml2) ||\r\n            eventEXP.exec(newHtml2);\r\n        if (kv) {\r\n            kvArr.push(kv[0]);\r\n            newHtml2 = newHtml2.replace(kv[0], '');\r\n        }\r\n    }\r\n    //todo 将键值对数组拆分保存到event对象中\r\n    kvArr.forEach((item) => {\r\n        let kv = item.split('='); //从等号拆分\r\n        const k = kv[0]; //对key value进行处理\r\n        const v = kv[1].slice(1, kv[1].length - 1).split(' ');\r\n        props[k] = v; //赋值给对象\r\n    });\r\n    return { newHtml2, props };\r\n}\r\n//! 将html模板字符串转换成tokens数组\r\nfunction collectTokens(html) {\r\n    const scanner = new Scanner(html);\r\n    const tokens = [];\r\n    let word = '';\r\n    while (!scanner.eos()) {\r\n        // 扫描文本\r\n        const text = scanner.scanUntil('<');\r\n        scanner.scan('<');\r\n        tokens[tokens.length - 1] && tokens[tokens.length - 1].push(text);\r\n        // 扫描标签<>中的内容\r\n        word = scanner.scanUntil('>');\r\n        scanner.scan('>');\r\n        // 如果没有扫描到值，就跳过本次进行下一次扫描\r\n        if (!word)\r\n            continue;\r\n        //todo 对本次扫描的字符串进行事件处理\r\n        const { newHtml, event } = eventParser(word); //todo 拆分事件\r\n        word = newHtml;\r\n        const { newHtml2, props } = allPropsParser(word); //todo 拆分事件\r\n        word = newHtml2;\r\n        // 区分开始标签 # 和结束标签 /\r\n        if (word.startsWith('/')) {\r\n            tokens.push(['/', word.slice(1)]);\r\n        }\r\n        else {\r\n            //todo 如果有属性存在，则解析属性 (且将event添加进去)\r\n            const firstSpaceIdx = word.indexOf(' ');\r\n            if (firstSpaceIdx === -1) {\r\n                tokens.push(['#', word, Object.assign(Object.assign({}, event), props),]);\r\n            }\r\n            else {\r\n                // 解析属性\r\n                tokens.push(['#', word.slice(0, firstSpaceIdx), Object.assign(Object.assign({}, event), props)]);\r\n            }\r\n        }\r\n    }\r\n    return tokens;\r\n}\r\nexports.collectTokens = collectTokens;\r\n//! 将tokens数组形成dom树形结构\r\nfunction nestTokens(tokens) {\r\n    const nestedTokens = [];\r\n    const stack = [];\r\n    let collector = nestedTokens;\r\n    for (let i = 0, len = tokens.length; i < len; i++) {\r\n        const token = tokens[i];\r\n        switch (token[0]) {\r\n            case '#':\r\n                // 收集当前token\r\n                collector.push(token);\r\n                // 压入栈中\r\n                stack.push(token);\r\n                // 由于进入了新的嵌套结构，新建一个数组保存嵌套结构\r\n                // 并修改collector的指向\r\n                token.splice(2, 0, []);\r\n                collector = token[2];\r\n                break;\r\n            case '/':\r\n                // 出栈\r\n                stack.pop();\r\n                // 将收集器指向上一层作用域中用于存放嵌套结构的数组\r\n                collector = stack.length > 0\r\n                    ? stack[stack.length - 1][2]\r\n                    : nestedTokens;\r\n                break;\r\n            default:\r\n                collector.push(token);\r\n        }\r\n    }\r\n    return nestedTokens;\r\n}\r\nexports.nestTokens = nestTokens;\r\n//! 将tokens树转化为虚拟dom树\r\nfunction tokens2vdom(tokens) {\r\n    const vdom = {};\r\n    for (let i = 0, len = tokens.length; i < len; i++) {\r\n        const token = tokens[i];\r\n        vdom['tag'] = token[1];\r\n        vdom['props'] = token[3];\r\n        if (token[4]) {\r\n            vdom['text'] = token[token.length - 1];\r\n        }\r\n        else {\r\n            vdom['text'] = undefined;\r\n        }\r\n        const children = token[2];\r\n        if (children.length === 0) {\r\n            vdom['children'] = undefined;\r\n            continue;\r\n        }\r\n        ;\r\n        vdom['children'] = [];\r\n        for (let j = 0; j < children.length; j++) {\r\n            vdom['children'].push(tokens2vdom([children[j]]));\r\n        }\r\n        if (vdom['children'].length === 0) {\r\n            delete vdom['children'];\r\n        }\r\n    }\r\n    return vdom;\r\n}\r\nexports.tokens2vdom = tokens2vdom;\r\n//! 总和方法 转换html模板为虚拟dom\r\nfunction tplToVDOM(html) {\r\n    const tokensArr = collectTokens(html);\r\n    const tokensTree = nestTokens(tokensArr);\r\n    const vdom = tokens2vdom(tokensTree);\r\n    return vdom;\r\n}\r\nexports.tplToVDOM = tplToVDOM;\r\n\n\n//# sourceURL=webpack://myreact/./myReact/js/myJsx/tplToVnode.js?");

/***/ }),

/***/ "./src/App.css":
/*!*********************!*\
  !*** ./src/App.css ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://myreact/./src/App.css?");

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _page_Test__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./page/Test */ \"./src/page/Test.js\");\n/* harmony import */ var _page_Demo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./page/Demo */ \"./src/page/Demo.js\");\n/* harmony import */ var _App_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./App.css */ \"./src/App.css\");\n// Test小组件\r\n\r\n//功能测试页面\r\n\r\n//css引入测试\r\n\r\n\r\n\r\nfunction App() {\r\n\r\n  return {\r\n    components: { Demo: _page_Demo__WEBPACK_IMPORTED_MODULE_1__[\"default\"] },\r\n    data: {},\r\n    template: `<div>\r\n      <span className=\"red\">123</span>\r\n      <Demo></Demo>\r\n      <button type=\"button\" class=\"btn btn-primary\">Primary</button>\r\n    </div>`,\r\n  }\r\n}\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://myreact/./src/App.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _myReact_js_myHook_render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../myReact/js/myHook/render */ \"./myReact/js/myHook/render.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App */ \"./src/App.js\");\n\r\n\r\n\r\n// 渲染app\r\n(0,_myReact_js_myHook_render__WEBPACK_IMPORTED_MODULE_0__.render)(_App__WEBPACK_IMPORTED_MODULE_1__[\"default\"], document.getElementById('root'))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://myreact/./src/index.js?");

/***/ }),

/***/ "./src/page/Demo.js":
/*!**************************!*\
  !*** ./src/page/Demo.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _myReact_js_myHook_useEffect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../myReact/js/myHook/useEffect */ \"./myReact/js/myHook/useEffect.js\");\n/* harmony import */ var _myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../myReact/js/myHook/useState */ \"./myReact/js/myHook/useState.js\");\n\r\n\r\n\r\n\r\n//! 使用说明: 支持onclick事件绑定  渲染子组件  className设置  map渲染列表\r\n//! 定义的组件和方法需要使用$$挂载到全局\r\n\r\n\r\n//!定义子组件\r\nfunction Item() {\r\n    return {\r\n        template: `<button>子组件</button>`\r\n    }\r\n}\r\n\r\n\r\n//! Demo组件\r\nfunction Demo() {\r\n\r\n    const [age, setAge] = (0,_myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_1__.myUseState)(18)\r\n    const [num, setNum] = (0,_myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_1__.myUseState)(0)\r\n    const [arr, setArr] = (0,_myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_1__.myUseState)([])\r\n\r\n\r\n    //! 支持useEffect全系使用(return函数 同样会发生死循环)\r\n    ;(0,_myReact_js_myHook_useEffect__WEBPACK_IMPORTED_MODULE_0__.myUseEffect)(() => {\r\n        console.log('传入[],仅仅mount时执行');\r\n    }, [])\r\n\r\n    ;(0,_myReact_js_myHook_useEffect__WEBPACK_IMPORTED_MODULE_0__.myUseEffect)(() => {\r\n        console.log('不传 任意时候执行');\r\n    })\r\n\r\n    ;(0,_myReact_js_myHook_useEffect__WEBPACK_IMPORTED_MODULE_0__.myUseEffect)(() => {\r\n        setNum(num + 1)\r\n        console.log('监听age,age改变时执行');\r\n    }, [age])\r\n\r\n\r\n\r\n    //!定义onclick方法\r\n    function addNum() {\r\n        setNum(num + 1) //setArr并不是异步的  而是在App执行完毕之后才会进行更新\r\n    }\r\n    function addAge() {\r\n        setAge(age + 1)\r\n    }\r\n    function addArr() {\r\n        setArr([...arr, 'item'])\r\n    }\r\n\r\n\r\n    return ({\r\n        components: { Item },\r\n\r\n        data: { addNum, addAge, addArr },\r\n\r\n        template: `\r\n        <div>\r\n    \r\n        <h1>Demo</h1>\r\n        \r\n        <button onClick={addNum}>增加Num</button>\r\n        <button onClick={addAge}>增加Age和Num</button>\r\n        <button onClick={addArr}>增加Arr</button>\r\n    \r\n        <h3 className=\"red\">当前Num:${num}</h3>\r\n        <h3 className='red'>当前Age:${age}</h3>\r\n        \r\n        <div>\r\n        <Item></Item>\r\n        </div>\r\n        \r\n        <h4 className='red'>列表渲染测试</h4>\r\n    \r\n        ${arr.map((item) => {\r\n            return `<div>${item}</div>`\r\n        })}\r\n        \r\n        </div>\r\n            `\r\n    })\r\n}\r\n\r\n\r\n'1434 0.9版本'\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Demo);\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://myreact/./src/page/Demo.js?");

/***/ }),

/***/ "./src/page/Test.js":
/*!**************************!*\
  !*** ./src/page/Test.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../myReact/js/myHook/useState */ \"./myReact/js/myHook/useState.js\");\n\r\n\r\n\r\n\r\nfunction Test(props) {\r\n\r\n\r\n    const [num, setNum] = (0,_myReact_js_myHook_useState__WEBPACK_IMPORTED_MODULE_0__.myUseState)(0)\r\n\r\n    function addNum() {\r\n        setNum(num + 1)\r\n    }\r\n\r\n    return {\r\n        data: { addNum },\r\n        template: `<button onClick={addNum}>Num:${num}</button>`,\r\n    }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Test);\n\n//# sourceURL=webpack://myreact/./src/page/Test.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;